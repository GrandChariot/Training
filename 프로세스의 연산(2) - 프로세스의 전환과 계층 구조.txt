3-3. 프로세스의 연산(2) - 프로세스의 전환과 계층 구조

3. 프로세스의 전환
fork() 시스템 호출로 생성된 자식 프로세스는 exec() 시스템 호출을 통해 다른 프로세스로 변신할 수 있다.
왜 새로 생성하지 않고 이런 일을 하냐하면, 프로세스 제어 구조체를 그대로 사용할 수 있기 때문이다.
껍데기는 그대로 복제하고 내용물만 고쳐 쓰는 게 처음부터 빌드하는 것보다 빠르다는 뜻이다.

exec()의 동작 과정은 간단하다.
단순히 해당 프로세스의 코드 영역을 비우고 새로운 코드로 바꿔치운다.
이렇게 되면 데이터 영역에도 해당 코드가 필요로 하는 새로운 데이터가 들어오며 스택 영역은 리셋된다.
제어 블록 역시 프로세스 구분자 등 몇몇 칸은 남아있지만 대부분의 칸은 청소되고 새로운 내용이 들어찬다.

(질문: 이 때 경계 레지스터와 한계 레지스터가 바뀌지 않아도 괜찮은가?
서로 다른 프로그램끼리는 차지하는 메모리의 크기가 다를 텐데?)

기회가 된다면 리눅스에서 실제로 exec()를 사용하는 실습을 해보자.
이에 대해서는 추후 리눅스 시스템 프로그래밍을 공부해보면 좋을 것 같다.


4. 프로세스의 계층 구조
여기까지 읽었다면 한 가지 사실을 알 수 있다.
프로세스를 직접 만드는 것보다 복사 후 전환하는 게 훨씬 효율적이라면, 하나만 만들면 되지 않나?
그래서 그 역할을 담당하는 프로세스가 바로 'init 프로세스'이다.(어쩐지 파이썬에서 본 것 같다.)
유닉스에서 init을 제외한 다른 모든 프로세스는 init으로부터 파생된 프로세스이다.
init의 직계 자식 프로세스는 login 프로세스나 shell 프로세스 등이 있다.

여기서 login이야 익숙하지만, shell은 무엇인가?
shell은 파이썬에서 사실 한 번 사용해본 적이 있다.
사용자가 명령을 내리면 즉시 결과를 제공하는 프로세스가 바로 shell이다.

이들을 활용해서 사용자들이 리눅스에 로그인하고 리눅스를 사용하는 과정을 살펴보자.
우선, 사용자가 로그인하려 할 때 init은 자식 프로세스를 만든 후 이를 login 프로세스로 전환한다.
다수의 사용자가 로그인할 경우 간단하게 login 프로세스를 여러 개 복사한다.

그 뒤엔 사용자가 명령어를 입력하고 결과를 전달받기 위해 shell 프로세스가 필요한데
이때에는 shell 프로세스를 따로 실행할 필요 없이, 사용이 끝난 login 프로세스를 shell 프로세스로 전환하면 그만이다.

또한, shell을 통해 사용자가 어떠한 프로그램을 실행하고자 할 때
간단하게 shell을 복제한 후 이를 해당 프로그램의 프로세스로 변경한다.
이렇게 init - shell - 응용 프로그램의 계층구조가 만들어진다.


그런데, 이쯤 되면 당연하게 드는 의문이 있다.
자식 프로세스의 자원 회수를 부모 프로세스가 한다면, 부모 프로세스가 먼저 종료된다면 어떻게 해야하는가?
이렇게 부모를 잃은 프로세스를 '미아 프로세스'라고 부른다.
'미아 프로세스'가 종료되었을 때 자원은 회수될 수 없기 때문에 주기적으로 자원 회수를 해줘야한다.

파이썬에선 그럴 필요가 없었지만, C언어에서는 굳이 main 함수에 반환값까지 만들어가면서 return을 했다.
이렇게 일일이 return을 해주는 이유는 바로 이 return이 프로세스의 종료를 알리기 때문이다.
굳이 return을 해주지 않아도 언젠가 자원 회수를 해가긴 하겠지만, 있음으로써 바로바로 자원 회수를 할 수 있는 것이다.
이에 대해서는 역시 추후 자세히 다룰 예정이다. 