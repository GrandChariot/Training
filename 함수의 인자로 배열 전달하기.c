#include <stdio.h>

/*
함수의 인자를 전달하는 행위는 지금까지 본능적으로 해오고 있었다.
바로 함수의 괄호 안에 변수나 상수를 넣는 것이다.
하지만 거기에 배열을 넣을 수도 있는가?
이번 챕터의 내용은 매우매우 중요하므로 신경써서 배우도록 하자.
*/

void simplefunc(int temp)
{
	temp++;
	return;
}

int simplefunc2(int *arr, int length) // 포인터형 인자를 받아야 한다.
{
	int sum = 0;
	/*
	이때 받아들인 배열은, 배열 전체를 받아들인 게 아니라
	단순히 포인터(주소)를 받아들인 거라서 배열 자체와는 좀 다른 면이 있다.
	그러한 점에 주의하자.
	*/
	for (int i = 0;i < length;i++)
	{
		sum += arr[i];
	}
	arr[4] = 6; // 여기서 한 번 값을 바꿔본다.
	return sum;
}

int main(void)
{
	int num = 1;
	simplefunc(num); // 함수에 전달되는 인자는 num 그 자체가 아닌 값의 복사본이다.
	printf("num이 증가하지 않았다!: %d \n", num); // 함수 내부의 변화는 변수에 적용되지 않는다!

	/*
	그러나, 함수가 배열을 받아갈 때는 다르다.
	함수에 배열을 통째로 넘길 수는 없다.
	때문에 이때 함수에게 '배열의 접근 권한'을 부여하는 것이다.
	책에서는 이를 아파트에 비유하고 싶다.
	아파트를 보고 싶다는 사람한테 아파트를 통째로 넘겨줄 순 없으니
	아파트에 입장 권한을 줘서 입주민들을 하나하나 만나볼 수 있게 해주는 것이다
	*/

	int arr[] = { 1, 2, 3, 4, 5 };
	int length = sizeof(arr) / sizeof(int);
	printf("총합은 %d입니다. \n", simplefunc2(arr, length));
	printf("마지막 값이 %d으로 바뀌었습니다. \n", arr[4]);

	/*
	이땐 포인터를 제공하는 것이기 때문에, 원본 주소에 접근이 가능하고
	함수 내에서 변한 값은 함수 외부에서도 변한 것이다!
	다만 포인터를 제공하는 거지 arr 자체를 제공하는 것은 아니다.
	*/

	/*
	우리에게 익숙한 배열의 표현방식!
	인자를 (arr[])의 형태로 받을 수도 있지만
	이렇게 해도 배열 자체를 넘겨주는 건 아니고
	오로지 포인터만 복사해준다는 점에 주의해야 한다.
	*/

	return 0;
}