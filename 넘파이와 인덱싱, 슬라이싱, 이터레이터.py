import numpy as np

"""
배열은 리스트와 마찬가지로 슬라이싱과 인덱싱이 가능하다.
리스트의 슬라이싱, 인덱싱 방식만 그대로 이용해도 아주 자유롭게 다룰 수 있다.
"""

A = np.array([[1, 2, 3],
              [4, 5, 6]])

print(A[1, 2]) #이때 당연히 인덱스는 0부터 시작한다.
print(A[:, 0])
print(A[:, 0:1]) #위에 것과 이것의 차이에는 조금 주목할 필요가 있다.
print(A[0, :])
print(A[0:2, 0:2])

"""
이때, 한쪽을 정수로 설정하면 차원이 낮아지지만
하나만 남더라도 정수로 설정하지 않으면 차원이 그대로다.
이 점에 주의해서 사용하도록 하자.

단 하나의 원소만 추출하더라도, 인덱싱이 아닌 슬라이싱을 하면
차수가 그대로 유지된다!!
"""

"""
특정한 위치의 원소를 가져올 땐 인덱스를 가져오면 되지만
원소를 순서대로 호출하고 싶을 땐 어떻게 해야하는가?
그 때 사용하는 게 바로 이터레이터다.
C++은 아직 학습하지 않았기에 이터레이터 개념은 낯설다.
"""

it = np.nditer(A, flags=['multi_index'], op_flags=['readwrite']) #다소 길다.
#multi_index는 동작 형태, readwrite는 생성 형태를 의미한다.
print(it) #it 자체는 주소값만 가지며 출력값이 없는 포인터이다.

while not it.finished:
    print(it.multi_index, ": ", A[it.multi_index])
    it.iternext() #포인터 it가 가리키는 주소를 한 칸 옮긴다.
