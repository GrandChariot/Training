#include <stdio.h>

int main(void)
{
	/*
	비트 단위로만 연산을 진행해주는 연산자
	&, |, ^, ~, <<, >>의 여섯 가지가 있다.
	~를 빼고는 전부 결합방향은 왼쪽에서 오른쪽
	낯선 개념이니 신경써서 공부하자.
	*/

	int num1 = 15, num2 = 20;
	int num3 = num1 & num2;
	printf("%d \n", num3);

	/*
	&는 비트에 대해 and 연산을 실행한다.
	15는 00001111이고 20은 00010100이므로 반환되는 것은 00000100
	이를 int로 나타내면 4가 된다.
	*/

	int num4 = num1 | num2;
	printf("%d \n", num4);

	/*
	같은 원리로 or 연산을 실행한다.
	00001111과 00010100에 대해 or 연산을 진행하면 결과는 00011111
	이를 int로 나타내면 31
	*/

	int num5 = num1 ^ num2;
	printf("%d \n", num5);

	/*
	이건 xor 연산이다. 둘이 다르면 1을 반환한다.
	결과는 11011이 된다. 즉 27이다.
	*/

	int num6 = ~num1;
	printf("%d \n", num6);

	/*
	not 연산은 익숙하다.
	11110000을 반환할 것이며 이는 -16이다.
	not 연산은 2진수로 표시된 음수의 크기를 판별하는데에 유용하다.
	*/

	int num7 = num1 << 2;
	printf("%d \n", num7);
	int num8 = num1 >> 2;
	printf("%d, \n", num8);

	/*
	비트를 이동시키는 연산.
	00001111이 각각 00111100, 00000011이 된다.
	결과를 확인해보자.
	*/

	int num9 = -16;
	int num10 = -16 >> 2;
	printf("%d \n", num10);

	/*
	그런데 음수를 오른쪽으로 비트 이동 시킬 땐 특이한 현상이 나타난다.
	바로 맨 앞의 부호 표시를 유지하냐 안 유지하냐의 차이가 생긴다는 점이다.
	가령 -16은 11110000이다. 근데 11111100이 될까, 00111100이 될까?
	CPU에 따라 1을 채우는지 0을 채우는지 다르므로 직접 실험해보자.
	내 노트북은 -4를 띄우는 걸 보니 1을 채우나보다.
	*/

	return 0;
}