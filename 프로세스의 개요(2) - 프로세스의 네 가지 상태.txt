3-1. 프로세스의 개요(2) - 프로세스의 네 가지 상태

3. 프로세스의 네 가지 상태

프로세스에는 네 가지 상태가 있다.
- 생성 상태: 프로세스가 갓 메모리에 올라와 실행 준비가 된 상태. 프로세스 제어 블록이 생성된다.
- 준비 상태: 생성된 프로세스가 CPU를 할당받을 때까지 기다리는 상태이다.
- 실행 상태: 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 작업을 수행하는 상태이다.
1장에서 배웠던 '타임 슬라이스' 만큼의 실행 시간을 가진다. 시간이 지나면 '타임 아웃'이 된다.
- 완료 상태: '타임 슬라이스' 안에 프로세스가 요하는 모든 작업을 마치고 프로세서 제어 블록이 종료된 상태이다.

한 번 생성된 프로세스는 한 번 또는 여러 번 준비 상태와 실행 상태를 오간다.
이때 어떤 프로세스를 우선적으로 실행 상태로 옮길지는 'CPU 스케줄러'가 결정한다.
이렇게 준비 상태에서 실행 상태가 되는 것을 '디스패치'라고 한다.

그런데, 2장에서 공부했던 '입출력 관리자'와 '인터럽트'의 등장으로 인해 한 가지 상태가 더 필요해졌다.
그건 바로 데이터의 입출력을 기다리고 있는 '대기 상태'이다.

실행 상태의 프로그램이 데이터 입출력을 하염없이 기다리는 것은 매우 비효율적이다.
때문에 실행 상태의 프로그램이 데이터 입출력을 요구하면 해당 프로그램은 대기 상태로 옮겨진다.
입출력이 완료된 후 대기 상태에 있던 프로그램은 실행 상태가 아닌 준비 상태가 된다.


이제부터 각 상태에 대해 좀 더 상세하게 알아볼 예정이다.

- 준비 상태
준비 상태의 프로세스는 '준비 큐'에서 기다린다.('큐'는 자료구조에서 배웠다.)
실제로는 우선도에 따른 다수의 준비 큐가 있는데 이는 추후 다시 공부할 예정이다.
우선도가 제일 높은 프로세스는 dispatch(PID) 명령어를 통해 실행 상태로 이동한다.

- 실행 상태
실행 상태에 들어갈 수 있는 프로세스는 기본적으로 CPU의 개수와 동일하다.
CPU에 입장한 프로세스는 타임 슬라이스만큼의 시간동안 할 일을 할 수 있고,
타임 슬라이스가 전부 끝나면 timeout(PID) 명령어를 통해 다시 준비 상태가 된다.
그런데 만약 타임 슬라이스 내에 할 일이 전부 끝나면 exit(PID) 명령어를 통해 종료 상태로 이동한다.
그리고 입출력을 요구하면 block(PID) 명령어를 통해 작업이 중지되고 대기 상태로 옮겨진다.

- 대기 상태
대기 상태에 들어간 프로세스는 입출력장치별 큐에 배치된다.
입출력이 완료되고 인터럽트가 발생하면 프로세스를 깨워야 한다.
이 때 사용되는 명령어가 wakeup(PID)이다. 이를 통해 프로세스는 다시 준비 상태로 이동한다.

- 종료 상태
실행 상태에서 할 일을 전부 마치고 프로그램이 종료될 땐 exit() 명령어를 이용하지만
가끔 비정상적인 방법으로 프로세스가 종료되는 경우도 있다.
이때 디버깅을 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기는데, 이를 '코어 덤프'라고 한다.


이외에 특수한 상태로 '휴식 상태'와 '보류 상태'가 있다.
- 휴식 상태
프로그램이 잠시 멈춘 상태이다. 유닉스 계열 운영체제에서 Ctrl+Z를 눌러 확인해보자.
휴식 상태로 보내진 프로세스는 언제든지 작업하던 그 상태 그대로 도로 실행할 수 있다.
반대로 Ctrl+C를 누르면 완전히 종료가 된다.

- 보류 상태
프로세스가 보류 상태로 보내지는 것에는 다양한 이유가 있다.
악성코드로 판단되거나, 입출력이 오랫동안 지연되거나, 오류가 있거나, 메모리가 꽉 찼거나...
이렇게 쫓겨난 프로세스는 '스왑 영역'에 보관된다.
대기 상태에서 옮겨진 경우에는 '보류 대기 상태', 준비 상태에서 옮겨진 경우는 '보류 준비 상태'
보류 대기 상태에서 입출력이 완료되면 준비 상태가 아닌 보류 준비 상태로 이동한다는 점에 주의!
