#include <stdio.h>

/*
함수도 변수와 마찬가지로 메모리 공간에 저장되고
당연히 이를 지정할 수 있는 포인터가 있다.
*/

int SimpleFunc(int num)
{
	printf("%d \n", num);
	return num;
}

/*
여기 아주 간단한 함수가 있다.
그런데 이 함수의 자료형은 무엇일까? 하는 의문이 생긴다.

답은, 반환형과 매개변수를 통해 정해진다.
그래서 위 함수의 포인터는 반환형이 int이고 매개변수로 int 하나가 선언된 포인터다.
이제 한 번 함수의 포인터를 선언하고 그 크기를 확인해보자.
*/

int main(void)
{
	int (*fptr) (int);
	fptr = SimpleFunc; // 함수는 함수 자체가 포인터라 &를 붙이지 않아도 된다.
	
	int num = 5;
	fptr(num); // 이렇게 만든 포인터는 함수랑 완전 똑같이 사용할 수 있다.

	/*
	또한, 이를 이용하면 함수를 매개변수로 받는 함수를 만들 수 있다.
	이에 대해서는 교재의 예시를 참조하자.
	*/

	/*
	마지막으론 정말 정말 신기한 포인터를 배울 것이다.
	바로 void 포인터이다.
	*/

	void* ptr; // 이 포인터는 무엇이든 담을 수 있는 포인터 주머니다!
	/*
	정수, 실수, 문자열, 배열, 함수... 그 모든 것이든 담을 수 있는 만능 주머니!
	하지만 단점도 있는데 그 자체로는 아무 것도 할 수 없다.
	오로지 주소 값만 담을 수 있을 뿐 이에 대해 어떠한 연산도 할 수 없다.
	심지어 * 연산을 이용해서 주소에 저장된 값을 변경하는 것도 불가능하다.
	당연하지만 자료의 크기와 포인터의 크기가 달라지기 때문이다.
	이걸 대체 어디에 써야하나 싶지만, C의 깊은 이해에 유용한 녀석이다.
	*/

	return 0;

}